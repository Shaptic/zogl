/*
** Copyright (c) 2012 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

// Various functions for helping debug WebGL apps.

WebGLDebugUtils = function() {

/**
 * Wrapped logging function.
 * @param {string} msg Message to log.
 */
var log = function(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
};

/**
 * Wrapped error logging function.
 * @param {string} msg Message to log.
 */
var error = function(msg) {
  if (window.console && window.console.error) {
    window.console.error(msg);
  } else {
    log(msg);
  }
};


/**
 * Which arguments are enums based on the number of arguments to the function.
 * So
 *    'texImage2D': {
 *       9: { 0:true, 2:true, 6:true, 7:true },
 *       6: { 0:true, 2:true, 3:true, 4:true },
 *    },
 *
 * means if there are 9 arguments then 6 and 7 are enums, if there are 6
 * arguments 3 and 4 are enums
 *
 * @type {!Object.<number, !Object.<number, string>}
 */
var glValidEnumContexts = {
  // Generic setters and getters

  'enable': {1: { 0:true }},
  'disable': {1: { 0:true }},
  'getParameter': {1: { 0:true }},

  // Rendering

  'drawArrays': {3:{ 0:true }},
  'drawElements': {4:{ 0:true, 2:true }},

  // Shaders

  'createShader': {1: { 0:true }},
  'getShaderParameter': {2: { 1:true }},
  'getProgramParameter': {2: { 1:true }},
  'getShaderPrecisionFormat': {2: { 0: true, 1:true }},

  // Vertex attributes

  'getVertexAttrib': {2: { 1:true }},
  'vertexAttribPointer': {6: { 2:true }},

  // Textures

  'bindTexture': {2: { 0:true }},
  'activeTexture': {1: { 0:true }},
  'getTexParameter': {2: { 0:true, 1:true }},
  'texParameterf': {3: { 0:true, 1:true }},
  'texParameteri': {3: { 0:true, 1:true, 2:true }},
  'texImage2D': {
     9: { 0:true, 2:true, 6:true, 7:true },
     6: { 0:true, 2:true, 3:true, 4:true },
  },
  'texSubImage2D': {
    9: { 0:true, 6:true, 7:true },
    7: { 0:true, 4:true, 5:true },
  },
  'copyTexImage2D': {8: { 0:true, 2:true }},
  'copyTexSubImage2D': {8: { 0:true }},
  'generateMipmap': {1: { 0:true }},
  'compressedTexImage2D': {7: { 0: true, 2:true }},
  'compressedTexSubImage2D': {8: { 0: true, 6:true }},

  // Buffer objects

  'bindBuffer': {2: { 0:true }},
  'bufferData': {3: { 0:true, 2:true }},
  'bufferSubData': {3: { 0:true }},
  'getBufferParameter': {2: { 0:true, 1:true }},

  // Renderbuffers and framebuffers

  'pixelStorei': {2: { 0:true, 1:true }},
  'readPixels': {7: { 4:true, 5:true }},
  'bindRenderbuffer': {2: { 0:true }},
  'bindFramebuffer': {2: { 0:true }},
  'checkFramebufferStatus': {1: { 0:true }},
  'framebufferRenderbuffer': {4: { 0:true, 1:true, 2:true }},
  'framebufferTexture2D': {5: { 0:true, 1:true, 2:true }},
  'getFramebufferAttachmentParameter': {3: { 0:true, 1:true, 2:true }},
  'getRenderbufferParameter': {2: { 0:true, 1:true }},
  'renderbufferStorage': {4: { 0:true, 1:true }},

  // Frame buffer operations (clear, blend, depth test, stencil)

  'clear': {1: { 0:true }},
  'depthFunc': {1: { 0:true }},
  'blendFunc': {2: { 0:true, 1:true }},
  'blendFuncSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},
  'blendEquation': {1: { 0:true }},
  'blendEquationSeparate': {2: { 0:true, 1:true }},
  'stencilFunc': {3: { 0:true }},
  'stencilFuncSeparate': {4: { 0:true, 1:true }},
  'stencilMaskSeparate': {2: { 0:true }},
  'stencilOp': {3: { 0:true, 1:true, 2:true }},
  'stencilOpSeparate': {4: { 0:true, 1:true, 2:true, 3:true }},

  // Culling

  'cullFace': {1: { 0:true }},
  'frontFace': {1: { 0:true }},

  // ANGLE_instanced_arrays extension

  'drawArraysInstancedANGLE': {4: { 0:true }},
  'drawElementsInstancedANGLE': {5: { 0:true, 2:true }},

  // EXT_blend_minmax extension

  'blendEquationEXT': {1: { 0:true }},
};

/**
 * Map of numbers to names.
 * @type {Object}
 */
var glEnums = null;

/**
 * Initializes this module. Safe to call more than once.
 * @param {!WebGLRenderingContext} ctx A WebGL context. If
 *    you have more than one context it doesn't matter which one
 *    you pass in, it is only used to pull out constants.
 */
function init(ctx) {
  if (glEnums == null) {
    glEnums = { };
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'number') {
        glEnums[ctx[propertyName]] = propertyName;
      }
    }
  }
}

/**
 * Checks the utils have been initialized.
 */
function checkInit() {
  if (glEnums == null) {
    throw 'WebGLDebugUtils.init(ctx) not called';
  }
}

/**
 * Returns true or false if value matches any WebGL enum
 * @param {*} value Value to check if it might be an enum.
 * @return {boolean} True if value matches one of the WebGL defined enums
 */
function mightBeEnum(value) {
  checkInit();
  return (glEnums[value] !== undefined);
}

/**
 * Gets an string version of an WebGL enum.
 *
 * Example:
 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
 *
 * @param {number} value Value to return an enum for
 * @return {string} The string version of the enum.
 */
function glEnumToString(value) {
  checkInit();
  var name = glEnums[value];
  return (name !== undefined) ? ("gl." + name) :
      ("/*UNKNOWN WebGL ENUM*/ 0x" + value.toString(16) + "");
}

/**
 * Returns the string version of a WebGL argument.
 * Attempts to convert enum arguments to strings.
 * @param {string} functionName the name of the WebGL function.
 * @param {number} numArgs the number of arguments passed to the function.
 * @param {number} argumentIndx the index of the argument.
 * @param {*} value The value of the argument.
 * @return {string} The value as a string.
 */
function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {
  var funcInfo = glValidEnumContexts[functionName];
  if (funcInfo !== undefined) {
    var funcInfo = funcInfo[numArgs];
    if (funcInfo !== undefined) {
      if (funcInfo[argumentIndex]) {
        return glEnumToString(value);
      }
    }
  }
  if (value === null) {
    return "null";
  } else if (value === undefined) {
    return "undefined";
  } else {
    return value.toString();
  }
}

/**
 * Converts the arguments of a WebGL function to a string.
 * Attempts to convert enum arguments to strings.
 *
 * @param {string} functionName the name of the WebGL function.
 * @param {number} args The arguments.
 * @return {string} The arguments as a string.
 */
function glFunctionArgsToString(functionName, args) {
  // apparently we can't do args.join(",");
  var argStr = "";
  var numArgs = args.length;
  for (var ii = 0; ii < numArgs; ++ii) {
    argStr += ((ii == 0) ? '' : ', ') +
        glFunctionArgToString(functionName, numArgs, ii, args[ii]);
  }
  return argStr;
};


function makePropertyWrapper(wrapper, original, propertyName) {
  //log("wrap prop: " + propertyName);
  wrapper.__defineGetter__(propertyName, function() {
    return original[propertyName];
  });
  // TODO(gmane): this needs to handle properties that take more than
  // one value?
  wrapper.__defineSetter__(propertyName, function(value) {
    //log("set: " + propertyName);
    original[propertyName] = value;
  });
}

// Makes a function that calls a function on another object.
function makeFunctionWrapper(original, functionName) {
  //log("wrap fn: " + functionName);
  var f = original[functionName];
  return function() {
    //log("call: " + functionName);
    var result = f.apply(original, arguments);
    return result;
  };
}

/**
 * Given a WebGL context returns a wrapped context that calls
 * gl.getError after every command and calls a function if the
 * result is not gl.NO_ERROR.
 *
 * @param {!WebGLRenderingContext} ctx The webgl context to
 *        wrap.
 * @param {!function(err, funcName, args): void} opt_onErrorFunc
 *        The function to call when gl.getError returns an
 *        error. If not specified the default function calls
 *        console.log with a message.
 * @param {!function(funcName, args): void} opt_onFunc The
 *        function to call when each webgl function is called.
 *        You can use this to log all calls for example.
 * @param {!WebGLRenderingContext} opt_err_ctx The webgl context
 *        to call getError on if different than ctx.
 */
function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {
  opt_err_ctx = opt_err_ctx || ctx;
  init(ctx);
  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
        // apparently we can't do args.join(",");
        var argStr = "";
        var numArgs = args.length;
        for (var ii = 0; ii < numArgs; ++ii) {
          argStr += ((ii == 0) ? '' : ', ') +
              glFunctionArgToString(functionName, numArgs, ii, args[ii]);
        }
        error("WebGL error "+ glEnumToString(err) + " in "+ functionName +
              "(" + argStr + ")");
      };

  // Holds booleans for each GL error so after we get the error ourselves
  // we can still return it to the client app.
  var glErrorShadow = { };

  // Makes a function that calls a WebGL function and then calls getError.
  function makeErrorWrapper(ctx, functionName) {
    return function() {
      if (opt_onFunc) {
        opt_onFunc(functionName, arguments);
      }
      var result = ctx[functionName].apply(ctx, arguments);
      var err = opt_err_ctx.getError();
      if (err != 0) {
        glErrorShadow[err] = true;
        opt_onErrorFunc(err, functionName, arguments);
      }
      return result;
    };
  }

  // Make a an object that has a copy of every property of the WebGL context
  // but wraps all functions.
  var wrapper = {};
  for (var propertyName in ctx) {
    if (typeof ctx[propertyName] == 'function') {
       if (propertyName != 'getExtension') {
      wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
       } else {
      var wrapped = makeErrorWrapper(ctx, propertyName);
      wrapper[propertyName] = function () {
         var result = wrapped.apply(ctx, arguments);
         return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);
      };
       }
     } else {
       makePropertyWrapper(wrapper, ctx, propertyName);
     }
  }

  // Override the getError function with one that returns our saved results.
  wrapper.getError = function() {
    for (var err in glErrorShadow) {
      if (glErrorShadow.hasOwnProperty(err)) {
        if (glErrorShadow[err]) {
          glErrorShadow[err] = false;
          return err;
        }
      }
    }
    return ctx.NO_ERROR;
  };

  return wrapper;
}

function resetToInitialState(ctx) {
  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
  var tmp = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
  for (var ii = 0; ii < numAttribs; ++ii) {
    ctx.disableVertexAttribArray(ii);
    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
    ctx.vertexAttrib1f(ii, 0);
  }
  ctx.deleteBuffer(tmp);

  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
  for (var ii = 0; ii < numTextureUnits; ++ii) {
    ctx.activeTexture(ctx.TEXTURE0 + ii);
    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
  }

  ctx.activeTexture(ctx.TEXTURE0);
  ctx.useProgram(null);
  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
  ctx.disable(ctx.BLEND);
  ctx.disable(ctx.CULL_FACE);
  ctx.disable(ctx.DEPTH_TEST);
  ctx.disable(ctx.DITHER);
  ctx.disable(ctx.SCISSOR_TEST);
  ctx.blendColor(0, 0, 0, 0);
  ctx.blendEquation(ctx.FUNC_ADD);
  ctx.blendFunc(ctx.ONE, ctx.ZERO);
  ctx.clearColor(0, 0, 0, 0);
  ctx.clearDepth(1);
  ctx.clearStencil(-1);
  ctx.colorMask(true, true, true, true);
  ctx.cullFace(ctx.BACK);
  ctx.depthFunc(ctx.LESS);
  ctx.depthMask(true);
  ctx.depthRange(0, 1);
  ctx.frontFace(ctx.CCW);
  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
  ctx.lineWidth(1);
  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  // TODO: Delete this IF.
  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
  }
  ctx.polygonOffset(0, 0);
  ctx.sampleCoverage(1, false);
  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
  ctx.stencilMask(0xFFFFFFFF);
  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
  ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

  // TODO: This should NOT be needed but Firefox fails with 'hint'
  while(ctx.getError());
}

function makeLostContextSimulatingCanvas(canvas) {
  var unwrappedContext_;
  var wrappedContext_;
  var onLost_ = [];
  var onRestored_ = [];
  var wrappedContext_ = {};
  var contextId_ = 1;
  var contextLost_ = false;
  var resourceId_ = 0;
  var resourceDb_ = [];
  var numCallsToLoseContext_ = 0;
  var numCalls_ = 0;
  var canRestore_ = false;
  var restoreTimeout_ = 0;

  // Holds booleans for each GL error so can simulate errors.
  var glErrorShadow_ = { };

  canvas.getContext = function(f) {
    return function() {
      var ctx = f.apply(canvas, arguments);
      // Did we get a context and is it a WebGL context?
      if (ctx instanceof WebGLRenderingContext) {
        if (ctx != unwrappedContext_) {
          if (unwrappedContext_) {
            throw "got different context"
          }
          unwrappedContext_ = ctx;
          wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);
        }
        return wrappedContext_;
      }
      return ctx;
    }
  }(canvas.getContext);

  function wrapEvent(listener) {
    if (typeof(listener) == "function") {
      return listener;
    } else {
      return function(info) {
        listener.handleEvent(info);
      }
    }
  }

  var addOnContextLostListener = function(listener) {
    onLost_.push(wrapEvent(listener));
  };

  var addOnContextRestoredListener = function(listener) {
    onRestored_.push(wrapEvent(listener));
  };


  function wrapAddEventListener(canvas) {
    var f = canvas.addEventListener;
    canvas.addEventListener = function(type, listener, bubble) {
      switch (type) {
        case 'webglcontextlost':
          addOnContextLostListener(listener);
          break;
        case 'webglcontextrestored':
          addOnContextRestoredListener(listener);
          break;
        default:
          f.apply(canvas, arguments);
      }
    };
  }

  wrapAddEventListener(canvas);

  canvas.loseContext = function() {
    if (!contextLost_) {
      contextLost_ = true;
      numCallsToLoseContext_ = 0;
      ++contextId_;
      while (unwrappedContext_.getError());
      clearErrors();
      glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;
      var event = makeWebGLContextEvent("context lost");
      var callbacks = onLost_.slice();
      setTimeout(function() {
          //log("numCallbacks:" + callbacks.length);
          for (var ii = 0; ii < callbacks.length; ++ii) {
            //log("calling callback:" + ii);
            callbacks[ii](event);
          }
          if (restoreTimeout_ >= 0) {
            setTimeout(function() {
                canvas.restoreContext();
              }, restoreTimeout_);
          }
        }, 0);
    }
  };

  canvas.restoreContext = function() {
    if (contextLost_) {
      if (onRestored_.length) {
        setTimeout(function() {
            if (!canRestore_) {
              throw "can not restore. webglcontestlost listener did not call event.preventDefault";
            }
            freeResources();
            resetToInitialState(unwrappedContext_);
            contextLost_ = false;
            numCalls_ = 0;
            canRestore_ = false;
            var callbacks = onRestored_.slice();
            var event = makeWebGLContextEvent("context restored");
            for (var ii = 0; ii < callbacks.length; ++ii) {
              callbacks[ii](event);
            }
          }, 0);
      }
    }
  };

  canvas.loseContextInNCalls = function(numCalls) {
    if (contextLost_) {
      throw "You can not ask a lost contet to be lost";
    }
    numCallsToLoseContext_ = numCalls_ + numCalls;
  };

  canvas.getNumCalls = function() {
    return numCalls_;
  };

  canvas.setRestoreTimeout = function(timeout) {
    restoreTimeout_ = timeout;
  };

  function isWebGLObject(obj) {
    //return false;
    return (obj instanceof WebGLBuffer ||
            obj instanceof WebGLFramebuffer ||
            obj instanceof WebGLProgram ||
            obj instanceof WebGLRenderbuffer ||
            obj instanceof WebGLShader ||
            obj instanceof WebGLTexture);
  }

  function checkResources(args) {
    for (var ii = 0; ii < args.length; ++ii) {
      var arg = args[ii];
      if (isWebGLObject(arg)) {
        return arg.__webglDebugContextLostId__ == contextId_;
      }
    }
    return true;
  }

  function clearErrors() {
    var k = Object.keys(glErrorShadow_);
    for (var ii = 0; ii < k.length; ++ii) {
      delete glErrorShadow_[k];
    }
  }

  function loseContextIfTime() {
    ++numCalls_;
    if (!contextLost_) {
      if (numCallsToLoseContext_ == numCalls_) {
        canvas.loseContext();
      }
    }
  }

  // Makes a function that simulates WebGL when out of context.
  function makeLostContextFunctionWrapper(ctx, functionName) {
    var f = ctx[functionName];
    return function() {
      // log("calling:" + functionName);
      // Only call the functions if the context is not lost.
      loseContextIfTime();
      if (!contextLost_) {
        //if (!checkResources(arguments)) {
        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
        //  return;
        //}
        var result = f.apply(ctx, arguments);
        return result;
      }
    };
  }

  function freeResources() {
    for (var ii = 0; ii < resourceDb_.length; ++ii) {
      var resource = resourceDb_[ii];
      if (resource instanceof WebGLBuffer) {
        unwrappedContext_.deleteBuffer(resource);
      } else if (resource instanceof WebGLFramebuffer) {
        unwrappedContext_.deleteFramebuffer(resource);
      } else if (resource instanceof WebGLProgram) {
        unwrappedContext_.deleteProgram(resource);
      } else if (resource instanceof WebGLRenderbuffer) {
        unwrappedContext_.deleteRenderbuffer(resource);
      } else if (resource instanceof WebGLShader) {
        unwrappedContext_.deleteShader(resource);
      } else if (resource instanceof WebGLTexture) {
        unwrappedContext_.deleteTexture(resource);
      }
    }
  }

  function makeWebGLContextEvent(statusMessage) {
    return {
      statusMessage: statusMessage,
      preventDefault: function() {
          canRestore_ = true;
        }
    };
  }

  return canvas;

  function makeLostContextSimulatingContext(ctx) {
    // copy all functions and properties to wrapper
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'function') {
         wrappedContext_[propertyName] = makeLostContextFunctionWrapper(
             ctx, propertyName);
       } else {
         makePropertyWrapper(wrappedContext_, ctx, propertyName);
       }
    }

    // Wrap a few functions specially.
    wrappedContext_.getError = function() {
      loseContextIfTime();
      if (!contextLost_) {
        var err;
        while (err = unwrappedContext_.getError()) {
          glErrorShadow_[err] = true;
        }
      }
      for (var err in glErrorShadow_) {
        if (glErrorShadow_[err]) {
          delete glErrorShadow_[err];
          return err;
        }
      }
      return wrappedContext_.NO_ERROR;
    };

    var creationFunctions = [
      "createBuffer",
      "createFramebuffer",
      "createProgram",
      "createRenderbuffer",
      "createShader",
      "createTexture"
    ];
    for (var ii = 0; ii < creationFunctions.length; ++ii) {
      var functionName = creationFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          var obj = f.apply(ctx, arguments);
          obj.__webglDebugContextLostId__ = contextId_;
          resourceDb_.push(obj);
          return obj;
        };
      }(ctx[functionName]);
    }

    var functionsThatShouldReturnNull = [
      "getActiveAttrib",
      "getActiveUniform",
      "getBufferParameter",
      "getContextAttributes",
      "getAttachedShaders",
      "getFramebufferAttachmentParameter",
      "getParameter",
      "getProgramParameter",
      "getProgramInfoLog",
      "getRenderbufferParameter",
      "getShaderParameter",
      "getShaderInfoLog",
      "getShaderSource",
      "getTexParameter",
      "getUniform",
      "getUniformLocation",
      "getVertexAttrib"
    ];
    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
      var functionName = functionsThatShouldReturnNull[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    var isFunctions = [
      "isBuffer",
      "isEnabled",
      "isFramebuffer",
      "isProgram",
      "isRenderbuffer",
      "isShader",
      "isTexture"
    ];
    for (var ii = 0; ii < isFunctions.length; ++ii) {
      var functionName = isFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return false;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    wrappedContext_.checkFramebufferStatus = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.checkFramebufferStatus);

    wrappedContext_.getAttribLocation = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return -1;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getAttribLocation);

    wrappedContext_.getVertexAttribOffset = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return 0;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getVertexAttribOffset);

    wrappedContext_.isContextLost = function() {
      return contextLost_;
    };

    return wrappedContext_;
  }
}

return {
  /**
   * Initializes this module. Safe to call more than once.
   * @param {!WebGLRenderingContext} ctx A WebGL context. If
   *    you have more than one context it doesn't matter which one
   *    you pass in, it is only used to pull out constants.
   */
  'init': init,

  /**
   * Returns true or false if value matches any WebGL enum
   * @param {*} value Value to check if it might be an enum.
   * @return {boolean} True if value matches one of the WebGL defined enums
   */
  'mightBeEnum': mightBeEnum,

  /**
   * Gets an string version of an WebGL enum.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
   *
   * @param {number} value Value to return an enum for
   * @return {string} The string version of the enum.
   */
  'glEnumToString': glEnumToString,

  /**
   * Converts the argument of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);
   *
   * would return 'TEXTURE_2D'
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} numArgs The number of arguments
   * @param {number} argumentIndx the index of the argument.
   * @param {*} value The value of the argument.
   * @return {string} The value as a string.
   */
  'glFunctionArgToString': glFunctionArgToString,

  /**
   * Converts the arguments of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} args The arguments.
   * @return {string} The arguments as a string.
   */
  'glFunctionArgsToString': glFunctionArgsToString,

  /**
   * Given a WebGL context returns a wrapped context that calls
   * gl.getError after every command and calls a function if the
   * result is not NO_ERROR.
   *
   * You can supply your own function if you want. For example, if you'd like
   * an exception thrown on any GL error you could do this
   *
   *    function throwOnGLError(err, funcName, args) {
   *      throw WebGLDebugUtils.glEnumToString(err) +
   *            " was caused by call to " + funcName;
   *    };
   *
   *    ctx = WebGLDebugUtils.makeDebugContext(
   *        canvas.getContext("webgl"), throwOnGLError);
   *
   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
   *     to call when gl.getError returns an error. If not specified the default
   *     function calls console.log with a message.
   * @param {!function(funcName, args): void} opt_onFunc The
   *     function to call when each webgl function is called. You
   *     can use this to log all calls for example.
   */
  'makeDebugContext': makeDebugContext,

  /**
   * Given a canvas element returns a wrapped canvas element that will
   * simulate lost context. The canvas returned adds the following functions.
   *
   * loseContext:
   *   simulates a lost context event.
   *
   * restoreContext:
   *   simulates the context being restored.
   *
   * lostContextInNCalls:
   *   loses the context after N gl calls.
   *
   * getNumCalls:
   *   tells you how many gl calls there have been so far.
   *
   * setRestoreTimeout:
   *   sets the number of milliseconds until the context is restored
   *   after it has been lost. Defaults to 0. Pass -1 to prevent
   *   automatic restoring.
   *
   * @param {!Canvas} canvas The canvas element to wrap.
   */
  'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,

  /**
   * Resets a context to the initial state.
   * @param {!WebGLRenderingContext} ctx The webgl context to
   *     reset.
   */
  'resetToInitialState': resetToInitialState
};

}();

// glMatrix v0.9.5
glMatrixArrayType=typeof Float32Array!="undefined"?Float32Array:typeof WebGLFloatArray!="undefined"?WebGLFloatArray:Array;var vec3={};vec3.create=function(a){var b=new glMatrixArrayType(3);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2]}return b};vec3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b};vec3.add=function(a,b,c){if(!c||a==c){a[0]+=b[0];a[1]+=b[1];a[2]+=b[2];return a}c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];return c};
vec3.subtract=function(a,b,c){if(!c||a==c){a[0]-=b[0];a[1]-=b[1];a[2]-=b[2];return a}c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c};vec3.negate=function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b};vec3.scale=function(a,b,c){if(!c||a==c){a[0]*=b;a[1]*=b;a[2]*=b;return a}c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};
vec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g==1){b[0]=c;b[1]=d;b[2]=e;return b}}else{b[0]=0;b[1]=0;b[2]=0;return b}g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};vec3.cross=function(a,b,c){c||(c=a);var d=a[0],e=a[1];a=a[2];var g=b[0],f=b[1];b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c};vec3.length=function(a){var b=a[0],c=a[1];a=a[2];return Math.sqrt(b*b+c*c+a*a)};vec3.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]};
vec3.direction=function(a,b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1];a=a[2]-b[2];b=Math.sqrt(d*d+e*e+a*a);if(!b){c[0]=0;c[1]=0;c[2]=0;return c}b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c};vec3.lerp=function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);return d};vec3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+"]"};var mat3={};
mat3.create=function(a){var b=new glMatrixArrayType(9);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9]}return b};mat3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b};mat3.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a};
mat3.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b};mat3.toMat4=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=0;b[4]=a[3];b[5]=a[4];b[6]=a[5];b[7]=0;b[8]=a[6];b[9]=a[7];b[10]=a[8];b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
mat3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+"]"};var mat4={};mat4.create=function(a){var b=new glMatrixArrayType(16);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15]}return b};
mat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]=a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b};
mat4.determinant=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],i=a[7],j=a[8],k=a[9],l=a[10],o=a[11],m=a[12],n=a[13],p=a[14];a=a[15];return m*k*h*e-j*n*h*e-m*f*l*e+g*n*l*e+j*f*p*e-g*k*p*e-m*k*d*i+j*n*d*i+m*c*l*i-b*n*l*i-j*c*p*i+b*k*p*i+m*f*d*o-g*n*d*o-m*c*h*o+b*n*h*o+g*c*p*o-b*f*p*o-j*f*d*a+g*k*d*a+j*c*h*a-b*k*h*a-g*c*l*a+b*f*l*a};
mat4.inverse=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],i=a[6],j=a[7],k=a[8],l=a[9],o=a[10],m=a[11],n=a[12],p=a[13],r=a[14],s=a[15],A=c*h-d*f,B=c*i-e*f,t=c*j-g*f,u=d*i-e*h,v=d*j-g*h,w=e*j-g*i,x=k*p-l*n,y=k*r-o*n,z=k*s-m*n,C=l*r-o*p,D=l*s-m*p,E=o*s-m*r,q=1/(A*E-B*D+t*C+u*z-v*y+w*x);b[0]=(h*E-i*D+j*C)*q;b[1]=(-d*E+e*D-g*C)*q;b[2]=(p*w-r*v+s*u)*q;b[3]=(-l*w+o*v-m*u)*q;b[4]=(-f*E+i*z-j*y)*q;b[5]=(c*E-e*z+g*y)*q;b[6]=(-n*w+r*t-s*B)*q;b[7]=(k*w-o*t+m*B)*q;b[8]=(f*D-h*z+j*x)*q;
b[9]=(-c*D+d*z-g*x)*q;b[10]=(n*v-p*t+s*A)*q;b[11]=(-k*v+l*t-m*A)*q;b[12]=(-f*C+h*y-i*x)*q;b[13]=(c*C-d*y+e*x)*q;b[14]=(-n*u+p*B-r*A)*q;b[15]=(k*u-l*B+o*A)*q;return b};mat4.toRotationMat=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
mat4.toMat3=function(a,b){b||(b=mat3.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b};mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,o=-k*g+h*i,m=j*g-f*i,n=c*l+d*o+e*m;if(!n)return null;n=1/n;b||(b=mat3.create());b[0]=l*n;b[1]=(-k*d+e*j)*n;b[2]=(h*d-e*f)*n;b[3]=o*n;b[4]=(k*c-e*i)*n;b[5]=(-h*c+e*g)*n;b[6]=m*n;b[7]=(-j*c+d*i)*n;b[8]=(f*c-d*g)*n;return b};
mat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],o=a[9],m=a[10],n=a[11],p=a[12],r=a[13],s=a[14];a=a[15];var A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14];b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*o+u*r;c[2]=A*g+B*j+t*m+u*s;c[3]=A*f+B*k+t*n+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*o+y*r;c[6]=v*g+w*j+x*m+y*s;c[7]=v*f+w*k+x*n+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*o+E*r;c[10]=z*
g+C*j+D*m+E*s;c[11]=z*f+C*k+D*n+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*o+b*r;c[14]=q*g+F*j+G*m+b*s;c[15]=q*f+F*k+G*n+b*a;return c};mat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1];b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c};
mat4.multiplyVec4=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[3]=a[3]*d+a[7]*e+a[11]*g+a[15]*b;return c};
mat4.translate=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[12]=a[0]*d+a[4]*e+a[8]*b+a[12];a[13]=a[1]*d+a[5]*e+a[9]*b+a[13];a[14]=a[2]*d+a[6]*e+a[10]*b+a[14];a[15]=a[3]*d+a[7]*e+a[11]*b+a[15];return a}var g=a[0],f=a[1],h=a[2],i=a[3],j=a[4],k=a[5],l=a[6],o=a[7],m=a[8],n=a[9],p=a[10],r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=o;c[8]=m;c[9]=n;c[10]=p;c[11]=r;c[12]=g*d+j*e+m*b+a[12];c[13]=f*d+k*e+n*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+o*e+r*b+a[15];return c};
mat4.scale=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[0]*=d;a[1]*=d;a[2]*=d;a[3]*=d;a[4]*=e;a[5]*=e;a[6]*=e;a[7]*=e;a[8]*=b;a[9]*=b;a[10]*=b;a[11]*=b;return a}c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};
mat4.rotate=function(a,b,c,d){var e=c[0],g=c[1];c=c[2];var f=Math.sqrt(e*e+g*g+c*c);if(!f)return null;if(f!=1){f=1/f;e*=f;g*=f;c*=f}var h=Math.sin(b),i=Math.cos(b),j=1-i;b=a[0];f=a[1];var k=a[2],l=a[3],o=a[4],m=a[5],n=a[6],p=a[7],r=a[8],s=a[9],A=a[10],B=a[11],t=e*e*j+i,u=g*e*j+c*h,v=c*e*j-g*h,w=e*g*j-c*h,x=g*g*j+i,y=c*g*j+e*h,z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;if(d){if(a!=d){d[12]=a[12];d[13]=a[13];d[14]=a[14];d[15]=a[15]}}else d=a;d[0]=b*t+o*u+r*v;d[1]=f*t+m*u+s*v;d[2]=k*t+n*u+A*v;d[3]=l*t+p*u+B*
v;d[4]=b*w+o*x+r*y;d[5]=f*w+m*x+s*y;d[6]=k*w+n*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+o*e+r*g;d[9]=f*z+m*e+s*g;d[10]=k*z+n*e+A*g;d[11]=l*z+p*e+B*g;return d};mat4.rotateX=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[4],g=a[5],f=a[6],h=a[7],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[0]=a[0];c[1]=a[1];c[2]=a[2];c[3]=a[3];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[4]=e*b+i*d;c[5]=g*b+j*d;c[6]=f*b+k*d;c[7]=h*b+l*d;c[8]=e*-d+i*b;c[9]=g*-d+j*b;c[10]=f*-d+k*b;c[11]=h*-d+l*b;return c};
mat4.rotateY=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[4]=a[4];c[5]=a[5];c[6]=a[6];c[7]=a[7];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*-d;c[1]=g*b+j*-d;c[2]=f*b+k*-d;c[3]=h*b+l*-d;c[8]=e*d+i*b;c[9]=g*d+j*b;c[10]=f*d+k*b;c[11]=h*d+l*b;return c};
mat4.rotateZ=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[4],j=a[5],k=a[6],l=a[7];if(c){if(a!=c){c[8]=a[8];c[9]=a[9];c[10]=a[10];c[11]=a[11];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*d;c[1]=g*b+j*d;c[2]=f*b+k*d;c[3]=h*b+l*d;c[4]=e*-d+i*b;c[5]=g*-d+j*b;c[6]=f*-d+k*b;c[7]=h*-d+l*b;return c};
mat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b=a*b;return mat4.frustum(-b,b,-a,a,c,d,e)};
mat4.ortho=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/i;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/j;f[11]=0;f[12]=-(a+b)/h;f[13]=-(d+c)/i;f[14]=-(g+e)/j;f[15]=1;return f};
mat4.lookAt=function(a,b,c,d){d||(d=mat4.create());var e=a[0],g=a[1];a=a[2];var f=c[0],h=c[1],i=c[2];c=b[1];var j=b[2];if(e==b[0]&&g==c&&a==j)return mat4.identity(d);var k,l,o,m;c=e-b[0];j=g-b[1];b=a-b[2];m=1/Math.sqrt(c*c+j*j+b*b);c*=m;j*=m;b*=m;k=h*b-i*j;i=i*c-f*b;f=f*j-h*c;if(m=Math.sqrt(k*k+i*i+f*f)){m=1/m;k*=m;i*=m;f*=m}else f=i=k=0;h=j*f-b*i;l=b*k-c*f;o=c*i-j*k;if(m=Math.sqrt(h*h+l*l+o*o)){m=1/m;h*=m;l*=m;o*=m}else o=l=h=0;d[0]=k;d[1]=h;d[2]=c;d[3]=0;d[4]=i;d[5]=l;d[6]=j;d[7]=0;d[8]=f;d[9]=
o;d[10]=b;d[11]=0;d[12]=-(k*e+i*g+f*a);d[13]=-(h*e+l*g+o*a);d[14]=-(c*e+j*g+b*a);d[15]=1;return d};mat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+", "+a[9]+", "+a[10]+", "+a[11]+", "+a[12]+", "+a[13]+", "+a[14]+", "+a[15]+"]"};quat4={};quat4.create=function(a){var b=new glMatrixArrayType(4);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3]}return b};quat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b};
quat4.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a==b){a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return a}b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};quat4.inverse=function(a,b){if(!b||a==b){a[0]*=1;a[1]*=1;a[2]*=1;return a}b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};quat4.length=function(a){var b=a[0],c=a[1],d=a[2];a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};
quat4.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(f==0){b[0]=0;b[1]=0;b[2]=0;b[3]=0;return b}f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};quat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2];a=a[3];var f=b[0],h=b[1],i=b[2];b=b[3];c[0]=d*b+a*f+e*i-g*h;c[1]=e*b+a*h+g*f-d*i;c[2]=g*b+a*i+d*h-e*f;c[3]=a*b-d*f-e*h-g*i;return c};
quat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=a[0];var f=a[1],h=a[2];a=a[3];var i=a*d+f*g-h*e,j=a*e+h*d-b*g,k=a*g+b*e-f*d;d=-b*d-f*e-h*g;c[0]=i*a+d*-b+j*-h-k*-f;c[1]=j*a+d*-f+k*-b-i*-h;c[2]=k*a+d*-h+i*-f-j*-b;return c};quat4.toMat3=function(a,b){b||(b=mat3.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=k+g;b[4]=1-(j+e);b[5]=d-f;b[6]=c-h;b[7]=d+f;b[8]=1-(j+l);return b};
quat4.toMat4=function(a,b){b||(b=mat4.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=0;b[4]=k+g;b[5]=1-(j+e);b[6]=d-f;b[7]=0;b[8]=c-h;b[9]=d+f;b[10]=1-(j+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};quat4.slerp=function(a,b,c,d){d||(d=a);var e=c;if(a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]<0)e=-1*c;d[0]=1-c*a[0]+e*b[0];d[1]=1-c*a[1]+e*b[1];d[2]=1-c*a[2]+e*b[2];d[3]=1-c*a[3]+e*b[3];return d};
quat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+"]"};

gl = null;
glGlobals = {};
zogl = {};

function sum(list) {
    var s = 0;
    for (var i in list) {
        s += parseFloat(list[i]);
    }
    return s;
};

zogl.rad = function(deg) {
    return deg * Math.PI / 180.0;
};

zogl.deg = function(rad) {
    return rad * 180.0 / Math.PI;
};

zogl.getMousePosition = function(evt) {
    var rect = glGlobals.canvas.getBoundingClientRect();
    return {
        x:  evt.clientX - rect.left,
        y:  evt.clientY - rect.top,
    }
};

zogl.rect = function(x, y, w, h) {
    this.x = x || 0;
    this.y = y || 0;
    this.w = w || 0;
    this.h = h || 0;
};

zogl.rect.prototype.collideRect = function(rect) {
    var top1    = this.y,
        bottom1 = this.y + this.h,
        right1  = this.x + this.w,
        left1   = this.x;

    var top2    = rect.y,
        bottom2 = rect.y + rect.h,
        right2  = rect.x + rect.w,
        left2   = rect.x;

    if (bottom1 <= top2     || 
        top1    >= bottom2  ||
        right1  <= left2    ||
        left1   >= right2) {
        return false;
    }

    return true;
};

zogl.rect.prototype.collidePosition = function(x, y) {
    return this.collideRect(new zogl.rect(x, y, 1, 1));
};

/**
 * Accepts lots of formats for color values:
 *
 *  new color4([r, g, b, a]);   // list of components
 *  new color4('#FFFFFF');      // hex RGB
 *  new color4('#FFFFFF00');    // hex RGBA
 *
 **/
zogl.color4 = function(clr) {
    this.set(clr);
};

zogl.color4.prototype.asHex = function() {
    return '#' + (
        (this.r * 255) << 24 ^
        (this.g * 255) << 16 ^
        (this.b * 255) << 8  ^
        (this.a * 255)
    ).toString(16);
};

zogl.color4.prototype.asRGBA = function() {
    return [
        this.r * 255,
        this.g * 255,
        this.b * 255,
        this.a * 255
    ];
}

zogl.color4.prototype.asGL = function() {
    return new Float32Array([
        this.r,
        this.g,
        this.b,
        this.a
    ]);
};

zogl.color4.prototype.set = function() {

    // if the first arg is an array, we assume that
    // we were given an array of args instead of varargs
    // so we treat [0] as the varargs.
    var args = arguments;
    if (arguments[0] instanceof Array) {
        args = arguments[0];
    }

    // rgb or rgba components
    if (args.length >= 3) {

        // smartly detect whether we are in the
        // [0, 1] or [0, 255] range.
        if (sum(args) <= 4) {
            this.r = args[0];
            this.g = args[1];
            this.b = args[2];
            this.a = args[3] || 1;

        } else {
            this.r = args[0] / 255;
            this.g = args[1] / 255;
            this.b = args[2] / 255;
            this.a = (args[3] / 255) || 1;
        }

    // hex string
    // todo: rgba support
    } else if (args.length == 1 && typeof args[0] == "string") {
        if (args[0][0] == '#') args[0] = args[0].slice(1);

        var hex = parseInt(args[0], 16);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8  & 255) / 255;
        this.b = (hex       & 255) / 255;
        this.a = 1;

    // copy the color
    } else if (args.length == 1 && args[0] instanceof zogl.color4) {
        this.r = args[0].r;
        this.b = args[0].g;
        this.b = args[0].b;
        this.a = args[0].a || 1;

    // args are shit
    } else {
        log('incompatible');
        throw('incompatible');
    }
}

function log() {
    for(var i in arguments) {
        console.log(arguments[i]);
    }
}

zogl.onGLError = function(err, funcName, args) {
    var str = "";
    for (var i in args) {
        str += args[i] + ", ";
    }

    log('An error occured calling "gl.' + funcName +
        "(" + str.slice(0, -2) + ')": ' + err);
};

/*
 * @param   canvas  The canvas object for which we will create a WebGL context
 * @return  `true`  if a WebGL context could be created,
 *          `false` otherwise.
 */
zogl.init = function(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl");

        if (zogl.debug) {
            gl = WebGLDebugUtils.makeDebugContext(gl, zogl.onGLError);
        }
    } catch (e) {
    }

    if (!gl) {
        alert('WebGL is not supported!');
        return false;
    }

    gl.viewportWidth    = canvas.width;
    gl.viewportHeight   = canvas.height;
    gl.viewport(0, 0, canvas.width, canvas.height);

    glGlobals.mv    = mat4.create();
    glGlobals.proj  = mat4.create();
    glGlobals.canvas= canvas;

    mat4.identity(glGlobals.mv);
    mat4.ortho(0, canvas.width, canvas.height, 0, 1.0, 10.0, glGlobals.proj);

    // prevent context menu
    glGlobals.canvas.oncontextmenu = function(event) {
        event.preventDefault();
    };

    return true;
};

zogl.loadScript = function(filename, callback) {
    var node    = document.createElement("script");
    node.type   = "text/javascript";
    node.src    = "js/" + filename;
    node.onload = callback;
    document.getElementsByTagName('head')[0].appendChild(node);
};

zogl = zogl || {};

zogl.SHADERS = {
    'defaultvs' : [
        'attribute vec2 in_vert;',
        'attribute vec4 in_color;',
        'attribute vec2 in_texc;',

        'uniform mat4 mv;',
        'uniform mat4 proj;',

        'varying vec2 vs_texc;',
        'varying vec4 vs_color;',

        'void main(void) {',
            'gl_Position = proj * mv * vec4(in_vert, -1.0, 1.0);',
            'vs_color = in_color;',
            'vs_texc  = in_texc;',
        '}'
    ].join('\n'),

    'defaultfs' : [
        'precision mediump float;',

        'varying vec2 vs_texc;',
        'varying vec4 vs_color;',

        'uniform sampler2D texture;',

        'void main(void) {',
            'gl_FragColor = vs_color * texture2D(texture, vs_texc);',
        '}'
    ].join('\n'),

    'pointLightFS' : [
        'precision mediump float;',

        'varying vec2 vs_texc;',
        'varying vec4 vs_color;',

        'uniform sampler2D texture;',

        'uniform int    scr_height;',
        'uniform float  light_brt;',
        'uniform vec2   light_pos;',
        'uniform vec3   light_att;',
        'uniform vec4   light_col;',

        'void main(void) {',
            'vec2 pixel      = gl_FragCoord.xy;',
            'pixel.y         = float(scr_height) - pixel.y;',

            // Calculate distance to light from fragment.'
            'vec2 light_vec  = light_pos - pixel;',
            'float dist      = length(light_vec);',

            // Calculate attenuation, or light influence factor.
            'float att       = 1.0 / ( light_att.x +',
                                    '( light_att.y * dist) +',
                                    '( light_att.z * dist * dist));',

            // Final fragment color is the light color * attenuation * brightness.
            'vec4 tmp        = texture2D(texture, vs_texc) *',
            '                  light_col * vec4(att, att, att, 1.0);',
            'gl_FragColor    = tmp * light_brt * vs_color;',
        '}'
    ].join('\n'),

    'ambientLightFS': [
        'precision mediump float;',

        'varying vec2 vs_texc;',
        'varying vec4 vs_color;',

        'uniform vec4        light_col;',
        'uniform float       light_brt;',
        'uniform sampler2D   texture;',

        'void main()',
        '{',
            'gl_FragColor   = light_brt * light_col;',
            'gl_FragColor  *= vs_color * texture2D(texture, vs_texc);',
        '}'
    ].join('\n')
};

zogl = zogl || {};

zogl.zTexture = function() {
    this.id = 0;
    this.filename = "";
    this.size = {
        'w': 0,
        'h': 0
    };
    this.loaded = false;
    this.resetOnload();
};

zogl.zTexture.prototype.loadFromFile = function(filename) {
    this.loadFromRaw([255, 255, 255, 255], false, 1, 1);

    this.filename = filename;
    this.id.image = new Image();
    this.id.image.onload = this.callback;
    this.id.image.src = filename;
};

zogl.zTexture.prototype.loadFromRaw = function(data, flip_y, w, h) {
    this.filename = this.filename || "raw data";
    this.id = this.id || gl.createTexture();
    this.id.image = data;

    this.bind();

    if (flip_y) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    }

    if (w && h) {
        if (data instanceof Array) data = new Uint8Array(data);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA,
                      gl.UNSIGNED_BYTE, data);
        this.size.w = w;
        this.size.h = h;

    } else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,
                      gl.UNSIGNED_BYTE, data);
        this.size.w = data.width;
        this.size.h = data.height;
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    this.unbind();
};

zogl.zTexture.prototype.bind = function() {
    gl.bindTexture(gl.TEXTURE_2D, this.id);
};

zogl.zTexture.prototype.unbind = function() {
    gl.bindTexture(gl.TEXTURE_2D, null);
};

zogl.zTexture.prototype.setOnload = function(fn) {
    // If we're already loaded, there's no need to set a true callback,
    // just execute immediately.
    if (this.loaded) {
        fn();
    }

    // We still need to set it, though, for subsequent loads (if any).
    var tmp = this.callback;
    this.callback = function() {
        tmp();
        fn();
    }

    if (this.id.image !== undefined) {
        this.id.image.onload = this.callback();
    }
};

zogl.zTexture.prototype.resetOnload = function() {
    var that = this;
    this.callback = function(texture) {
        that.loadFromRaw(that.id.image, true);
        that.loaded = true;
    };
};

zogl.zWindow = function(w, h) {
    this.size = {
        'w': w || gl.viewportWidth,
        'h': h || gl.viewportHeight
    };
    this.proj = mat4.create();
}

zogl.zWindow.prototype.init = function() {
    this.resize(this.size.w, this.size.h);
    glGlobals.activeWindow = this;
};

zogl.zWindow.prototype.resize = function(w, h) {
    this.size = { 'w': w, 'h': h };

    glGlobals.canvas.width  = w;
    glGlobals.canvas.height = h;

    gl.viewportWidth  = w;
    gl.viewportHeight = h;

    gl.viewport(0, 0, w, h);
    mat4.ortho(0, w, h, 0, 1.0, 10.0, this.proj);
    glGlobals.proj = this.proj;

    this.refresh();
};

zogl.zWindow.prototype.refresh = function() {
    delete glGlobals.defaultShader;
    delete glGlobals.defaultTexture;

    s = new zogl.zShader();
    s.loadFromString(zogl.SHADERS.defaultvs,
                     zogl.SHADERS.defaultfs);

    s.bind();
    s.setParameterMat("proj", glGlobals.proj);
    s.setParameterMat("mv", glGlobals.mv);

    t = new zogl.zTexture();
    t.loadFromRaw([255, 255, 255, 255], false, 1, 1);

    glGlobals.defaultShader  = s;
    glGlobals.defaultTexture = t;
};

zogl.zWindow.prototype.clear = function(color) {
    color = color || new zogl.color4('#000000');

    // http://stackoverflow.com/questions/3362471
    if (!(color instanceof zogl.color4)) {
        var TempObj = function(){};
        TempObj.prototype = zogl.color4.prototype;
        var tmp = new TempObj;
        color = zogl.color4.apply(tmp, arguments);
        if (!(Object(color) === color)) {
            color = tmp;
        }
    }

    gl.clearColor(color.r, color.g, color.b, color.a);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

zogl.zWindow.prototype.loop = function(fn) {
    requestAnimationFrame(fn);
};

zogl.zShader = function() {
    this.vs_fn = "";
    this.fs_fn = "";
    this.errorstr = "";

    this.vs = null;
    this.fs = null;
    this.program = null;
    this.uniforms = {};

    this.sources = (zogl.debug) ? [] : undefined;
}

zogl.zShader.prototype.loadFromString = function(vsstr, fsstr) {
    this.vs = this.loadFromStr(vsstr, gl.VERTEX_SHADER);
    this.fs = this.loadFromStr(fsstr, gl.FRAGMENT_SHADER);

    if (!this.vs || !this.fs) return false;

    this.vs_fn = 'vs_fromstr';
    this.fs_fn = 'fs_fromstr';

    return this.createProgram();
}

zogl.zShader.prototype.loadFromNode = function(vs_id, fs_id) {
    this.vs = this.loadFromID(vs_id, gl.VERTEX_SHADER);
    this.fs = this.loadFromID(fs_id, gl.FRAGMENT_SHADER);

    if (!this.vs || !this.fs) return false;

    this.vs_fn = vs_id;
    this.fs_fn = fs_id;

    return this.createProgram();
}

zogl.zShader.prototype.createProgram = function() {
    this.program = gl.createProgram();
    gl.attachShader(this.program, this.vs);
    gl.attachShader(this.program, this.fs);
    gl.linkProgram(this.program);

    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
        this.errorstr = "Error occured when linking shaders.";
        return false;
    }

    return true;
};

zogl.zShader.prototype.getParameterLocation = function(name) {
    if (!(name in this.uniforms)) {
        this.uniforms[name] = gl.getUniformLocation(this.program, name);
    }

    return this.uniforms[name];
};

zogl.zShader.prototype.getAttributeLocation = function(name) {
    return gl.getAttribLocation(this.program, name);
}

zogl.zShader.prototype.loadFromStr = function(str, type) {
    var shader = gl.createShader(type);

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        this.errorstr = gl.getShaderInfoLog(shader);
        return null;
    }

    if (zogl.debug) {
        this.sources.push(str);
    }

    return shader;
}

zogl.zShader.prototype.loadFromID = function(id, type) {
    var node = document.getElementById(id);
    if (!node) return null;

    var str = "";
    var k = node.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }

        k = k.nextSibling;
    }

    return this.loadFromStr(str, type);
};

zogl.zShader.prototype.setParameterMat = function(name, value) {
    gl.uniformMatrix4fv(this.getParameterLocation(name), false, value);
};

zogl.zShader.prototype.setParameterFl = function(name, values) {
    var loc = this.getParameterLocation(name);

    if (values === parseFloat(values) || values.length == 1) {
        gl.uniform1f(loc, values);
        return;
    }

    var fn = null;
    if (values.length == 2) {
        fn = gl.uniform2fv;
    } else if (values.length == 3) {
        fn = gl.uniform3fv;
    } else if (values.length == 4) {
        fn = gl.uniform4fv;
    } else {
        throw('invalid number of parameters');
        return;
    }

    fn(loc, values);
};

zogl.zShader.prototype.setParameterInt = function(name, values) {
    if (values === parseInt(values) || values.length == 1) {
        gl.uniform1i(this.getParameterLocation(name), values);
        return;
    }

    var fn = null;
    if (values.length == 2) {
        fn = gl.uniform2iv;
    } else if (values.length == 3) {
        fn = gl.uniform3iv;
    } else if (values.length == 4) {
        fn = gl.uniform4iv;
    } else {
        throw('invalid number of parameters');
        return;
    }

    fn(this.getParameterLocation(name), values);
};

zogl.zShader.prototype.setTexture = function(name, id) {
    gl.activeTexture(gl.TEXTURE0 + id);
    gl.uniform1i(this.getParameterLocation(name), id);
};

zogl.zShader.prototype.bind = function() {
    gl.useProgram(this.program);
    glGlobals.activeShader = this;
};

zogl.zShader.prototype.unbind = function() {
    gl.useProgram(null);
    glGlobals.activeShader = glGlobals.defaultShader;
};

zogl = zogl || {};

zogl.zBuffer = function(buffertype, drawtype, type) {
    this.bufferType = buffertype;
    this.drawType   = drawtype || gl.STATIC_DRAW;
    this.attribute  = null;
    this.size       = 0;
    this.itemSize   = 0;
    this.dataType   = type || Float32Array;
    this.data       = [];
    this.buffer     = gl.createBuffer();
};


zogl.zBuffer.prototype.addData = function(bufferdata, eachElem) {
    if (this.size) {
        throw('.offload() has been called, you can no longer add data to this buffer.')
        return false;
    }

    var offset = this.data.length;

    // we are adding data
    if (this.data.length > 0) {
        var copy = new this.dataType(this.data.length + bufferdata.length);

        for (var i in this.data) {
            copy[i] = this.data[i];
        }

        for(var i = 0; i < bufferdata.length; ++i) {
            copy[i + offset] = bufferdata[i];
        }

        this.data = copy;

    // first batch of data
    } else {
        this.data = bufferdata;
    }

    this.itemSize = eachElem;
    return offset;
};

zogl.zBuffer.prototype.offload = function() {
    if (!this.data || !this.data.length) return;

    this.bind();
    gl.bufferData(this.bufferType, this.data, this.drawType);
    this.size = this.data.length;
    this.data = [];
    this.unbind();
};

zogl.zBuffer.prototype.setAttribute = function(name) {
    this.attribute = glGlobals.activeShader.getAttributeLocation(name);
};

zogl.zBuffer.prototype.bind = function() {
    gl.bindBuffer(this.bufferType, this.buffer);
};

zogl.zBuffer.prototype.unbind = function() {
    gl.bindBuffer(this.bufferType, null);
};

zogl.zBuffer.prototype.prepare = function() {
    this.bind();
    if (this.attribute !== null) {
        gl.enableVertexAttribArray(this.attribute);
        gl.vertexAttribPointer(this.attribute, this.itemSize,
                               gl.FLOAT, false, 0, 0);
    }
};

zogl.zBufferSet = function(type) {
    this.buffers = {};
    this.type = type || gl.STATIC_DRAW;
};

zogl.zBufferSet.prototype.addData = function(data) {
    var offset = this.addIndices(data.indices);
    this.addPositions(data.positions);
    this.addColors(data.colors);
    this.addTexCoords(data.texcoords);
    return offset;
}

zogl.zBufferSet.prototype.addPositions = function(data) {
    if (!data || !data.length) return;

    if (!('positions' in this.buffers)) {
        this.buffers.positions = new zogl.zBuffer(gl.ARRAY_BUFFER, this.type);
    }

    var offset = this.buffers.positions.addData(data, 2);
    this.buffers.positions.setAttribute("in_vert");
    return offset;
};

zogl.zBufferSet.prototype.addIndices = function(data) {
    if (!data || !data.length) return;

    if (!('posIndex' in this.buffers)) {
        this.buffers.posIndex = new zogl.zBuffer(gl.ELEMENT_ARRAY_BUFFER,
                                                 this.type, Uint16Array);
    }

    // divided by 2 because 2 floats per vert so the true count is size / 2.
    var offset = ('positions' in this.buffers        ?
                  this.buffers.positions.size +
                  this.buffers.positions.data.length : 0) / 2;

    for (var i in data) {
        data[i] += offset;
    }

    return this.buffers.posIndex.addData(data, 1);
};

zogl.zBufferSet.prototype.addColors = function(data) {
    if (!data || !data.length) return;

    if (!('colors' in this.buffers)) {
        this.buffers.colors = new zogl.zBuffer(gl.ARRAY_BUFFER, this.type);
    }

    var offset = this.buffers.colors.addData(data, 4);
    this.buffers.colors.setAttribute("in_color");
    return offset;
};

zogl.zBufferSet.prototype.addTexCoords = function(data) {
    if (!data || !data.length) return;

    if (!('texcoords' in this.buffers)) {
        this.buffers.texcoords = new zogl.zBuffer(gl.ARRAY_BUFFER, this.type);
    }

    var offset = this.buffers.texcoords.addData(data, 2);
    this.buffers.texcoords.setAttribute("in_texc");
    return offset;
};

zogl.zBufferSet.prototype.bind = function() {
    for (var i in this.buffers) {
        this.buffers[i].prepare();
    }
};

zogl.zBufferSet.prototype.unbind = function() {
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
};

zogl.zBufferSet.prototype.draw = function() {
    for (var i in this.buffers) {
        this.buffers[i].offload();
        this.buffers[i].prepare();
    }

    if ('posIndex' in this.buffers) {
        gl.drawElements(gl.TRIANGLES, this.buffers.posIndex.size,
                        gl.UNSIGNED_SHORT, 0);

    } else if ('positions' in this.buffers) {
        gl.drawArrays(gl.TRIANGLES, 0, this.buffers.positions.size /
                                       this.buffers.positions.numItems);
    }

    this.unbind();
};

zogl.zBufferSet.prototype.offload = function() {
    for (var i in this.buffers) {
        this.buffers[i].offload();
    }
};

zogl.zPolygon = function() {
    this.vao = null;
    this.internal = false;
    this.mv = mat4.create();
    mat4.identity(this.mv);

    this.drawData = {
        'positions':    [],
        'indices':      [],
        'colors':       [],
        'texcoords':    []
    };

    this.verts = [];
    this.color = new zogl.color4('#FFFFFF');

    this.x = 0;
    this.y = 0;

    this.shader  = glGlobals.defaultShader;
    this.texture = glGlobals.defaultTexture;

    this.size = {
        'w': 0,
        'h': 0
    };
};

zogl.zPolygon.prototype.clone = function() {
    var copy = new this.constructor();

    copy.drawData = {
        'positions':    new Float32Array(this.drawData.positions),
        'indices':      new Uint16Array (this.drawData.indices),
        'colors':       new Float32Array(this.drawData.colors),
        'texcoords':    new Float32Array(this.drawData.texcoords),
        'icount':       this.drawData.icount || 0,
        'vcount':       this.drawData.vcount || 0,
    };

    copy.x      = this.x;
    copy.y      = this.y;
    copy.shader = this.shader;
    copy.texture= this.texture;
    copy.verts  = this.verts.slice(0);
    copy.color  = new zogl.color4(this.color);
    copy.offset = 0;
    copy.size   = {
        'w': this.calcWidth(),
        'h': this.calcHeight()
    }

    mat4.translate(copy.mv, [copy.x, copy.y, 0]);

    return copy;
};

zogl.zPolygon.prototype.move = function(x, y) {
    this.x = x;
    this.y = y;
};

zogl.zPolygon.prototype.addVertex = function(x, y) {
    this.verts.push(x);
    this.verts.push(y);

    this.size = {
        'w': this.calcWidth(),
        'h': this.calcHeight()
    };
};

zogl.zPolygon.prototype.create = function() {
    if (this.verts.length <= 2) return false;

    if (!this.drawData.indices.length) {
        var tris = ((this.verts.length / 2) - 2) * 3;
        var indices = new Uint16Array(tris);

        for (var i = 0; i < tris; i += 3) {
            var x = i / 3;

            indices[i] = 0;
            indices[i+1] = x + 1;
            indices[i+2] = x + 2;
        }

        this.drawData.indices = indices;
        this.drawData.icount = indices.length;
    }

    this.drawData.texcoords = new Float32Array(this.verts.length);
    this.drawData.positions = new Float32Array(this.verts.length);
    this.drawData.colors    = new Float32Array(2 * this.verts.length);

    for (var i in this.verts) {
        this.drawData.colors[i*4]   = this.color.r;
        this.drawData.colors[i*4+1] = this.color.g;
        this.drawData.colors[i*4+2] = this.color.b;
        this.drawData.colors[i*4+3] = this.color.a;

        this.drawData.positions[i] = this.verts[i];
        this.drawData.texcoords[i] = 0;
    }

    this.drawData.vcount = this.verts.length;
    this.verts = [];
    return true;
};

zogl.zPolygon.prototype.draw = function(ready, shader) {
    var ready = ready || false;

    if (!ready) {
        if (this.vao === null) {
            this.vao = new zogl.zBufferSet();
            this.offset = this.vao.addData(this.drawData);
            this.vao.offload();
            this.internal = true;
        }

        this.vao.bind();
        this.prepareMaterial();

        if (shader !== undefined) {
            shader.bind();
        }
    }

    mat4.identity(this.mv);
    mat4.translate(this.mv, [this.x, this.y, 0]);

    glGlobals.activeShader.setParameterMat("mv", this.mv);
    glGlobals.activeShader.setParameterMat("proj", glGlobals.proj);

    gl.drawElements(gl.TRIANGLES, this.drawData.icount,
                    gl.UNSIGNED_SHORT, (new Uint16Array).BYTES_PER_ELEMENT * this.offset);
};

zogl.zPolygon.prototype.setColor = function(col) {
    this.color.set.apply(this.color, arguments);
};

zogl.zPolygon.prototype.getX = function() {
    return this.x;
};

zogl.zPolygon.prototype.getY = function() {
    return this.y;
};

zogl.zPolygon.prototype.offload = function(vao, flags) {
    if (this.drawData.positions.length == 0) {
        return;
    }

    this.offset = vao.addData(this.drawData);
    this.vao = vao;

    if (flags && flags.preserve == false) {
        delete this.drawData.positions;
        delete this.drawData.indices;
        delete this.drawData.colors;
        delete this.drawData.texcoords;

        this.drawData.positions = this.drawData.indices =
        this.drawData.colors    = this.drawData.texcoords = [];
    }
};

zogl.zPolygon.prototype.prepareMaterial = function() {
    this.getShader().bind();
    this.texture.bind();
};

zogl.zPolygon.prototype.getShader = function() {
    return this.shader;
};

zogl.zPolygon.prototype.setShader = function(s) {
    this.shader = s;
};

zogl.zPolygon.setColor = function(col) {
    this.color = new color4(col);
}

zogl.zPolygon.prototype.getTexture = function() {
    return this.texture;
};

zogl.zPolygon.prototype.calcWidth = function() {
    var set = this.verts.length == 0 ? this.drawData.positions : this.verts;

    var mw = 0;
    for (var i = 0; i < set.length; i += 2) {
        mw = Math.max(mw, set[i]);
    }
    this.size.w = mw;
    return mw;
};

zogl.zPolygon.prototype.calcHeight = function() {
    var set = this.verts.length == 0 ? this.drawData.positions : this.verts;

    var mh = 0;
    for (var i = 1; i < set.length; i += 2) {
        mh = Math.max(mh, set[i]);
    }
    this.size.h = mh;
    return mh;
};

zogl.zQuad = function(width, height) {
    zogl.zPolygon.call(this);
    this.resize(width, height);
}
zogl.zQuad.prototype = new zogl.zPolygon();
zogl.zQuad.prototype.constructor = zogl.zQuad;

zogl.zQuad.prototype.create = function() {
    this.loadVerts();
    this.loadTexCoords();

    this.drawData.colors = new Float32Array(
        this.drawData.positions.length * 2
    );

    for (var i in this.drawData.positions) {
        this.drawData.colors[i*4]   = this.color.r;
        this.drawData.colors[i*4+1] = this.color.g;
        this.drawData.colors[i*4+2] = this.color.b;
        this.drawData.colors[i*4+3] = this.color.a;
    }

    this.drawData.indices = new Uint16Array([
        0, 1, 3, 3, 1, 2
    ]);

    this.drawData.icount = 6;
    this.drawData.vcount = this.drawData.positions.length;
};

zogl.zQuad.prototype.resize = function(w, h) {
    this.size.w = w;
    this.size.h = h;

    if (this.drawData.positions.length > 0 &&
        this.verts.length > 0) {
        this.create();
    }
};

zogl.zQuad.prototype.loadVerts = function() {
    this.drawData.positions = new Float32Array([
        0,              0,
        this.size.w,    0,
        this.size.w,    this.size.h,
        0,              this.size.h
    ]);
};

zogl.zQuad.prototype.loadTexCoords = function() {
    this.drawData.texcoords = new Float32Array([
        0, 1,
        1, 1,
        1, 0,
        0, 0
    ]);
};

zogl.zQuad.prototype.attachTexture = function(texture) {
    this.texture = texture;
    this.setColor('#FFFFFF');
    if (!this.size.w || !this.size.h) {
        this.resize(texture.size.w, texture.size.h);
    }
};

zogl.zSprite = function() {
    this.rect = new zogl.rect();
    this.prims = [];
    this.passes = [];
    this.mv = mat4.create();
    this.enabled = true;
    this.flags = {
        'blend': false
    }

    mat4.identity(this.mv);
};

zogl.zSprite.prototype.loadFromTexture = function(texture) {
    if (typeof texture == "string") {
        var fn = texture;
        texture = new zogl.zTexture();
        texture.loadFromFile(fn);
    }

    this.rect.w = texture.size.w;
    this.rect.h = texture.size.h;

    var q = new zogl.zQuad(this.rect.w, this.rect.h);
    var that = this;
    texture.setOnload(function() {
        q.resize(texture.size.w, texture.size.h);
        q.attachTexture(texture);
        q.create();
        that.prims = [];
        that.addObject(q, 0, 0);
    });
};

zogl.zSprite.prototype.addObject = function(obj, x, y) {
    var tmp = obj.clone();
    tmp.move(x || 0, y || 0);
    this.prims.push(tmp);

    this.rect.w = Math.max(this.rect.w, obj.calcWidth()  + (x || 0));
    this.rect.h = Math.max(this.rect.h, obj.calcHeight() + (y || 0));
};

zogl.zSprite.prototype.move = function(x, y) {
    mat4.translate(this.mv, vec3.create(x, y, 0));
    this.rect.x = x; this.rect.y = y;
};

zogl.zSprite.prototype.adjust = function(dx, dy) {
    this.move(this.rect.x + dx, this.rect.y + dy);
};

zogl.zSprite.prototype.addPass = function(shader) {
    this.passes.push(shader);
};

zogl.zSprite.prototype.draw = function(ready) {
    if (!this.enabled) return;

    if (this.passes.length == 0) {
        this._drawPrims(ready);
        return;
    }

    var wontwork = true;
    if (this.passes.length == 1) {
        for (var i in this.prims) {
            if (this.prims[i].getShader() == undefined ||
                this.prims[i].getShader() == glGlobals.defaultShader ||
                this.prims[i].getShader() == this.passes[0]) {
                this.prims[i].setShader(this.passes[0]);
                wontwork = false;
            } else {
                wontwork = true;
                break;
            }
        }
    }

    if (!wontwork) {
        this._drawPrims(ready);
        return;
    }

    // We have some sort of custom shaders in the internal primitives.
    // This means that we need to RTT.

    // First, we need to calculate the total width of the internal
    // primitives. Since some are offset, real_size = offset + size.

    var mw = 0, mh = 0;
    for (var i in this.prims) {
        var w = this.prims[i].size.w + this.prims[i].getX();
        var h = this.prims[i].size.h + this.prims[i].getY();

        mw = mw > w ? mw : w;
        mh = mh > h ? mh : h;
    }

    var old_fbo = glGlobals.activeRenderTarget;
    var fbo1 = new zogl.zRenderTarget(mw, mh), fbo2 = null;
    var activeFBO = fbo1;
    if (this.passes.length > 1) {
        fbo2 = new zogl.zRenderTarget(mw, mh);
    }

    // Draw once to a texture.
    fbo1.bind();
    this._drawPrims(ready);

    // Load that texture into geometry.
    var final_texture = fbo1.texture;
    var q = new zogl.zQuad(mw, mh);
    q.create();

    /*
     * Do the pass in a ping-pong on that texture, swapping w/ each pass.
     *
     * i = 0:
     *  Texture #1 is bound, FBO #2 is bound. Result is in texture #2.
     *
     * i = 1:
     *  Texture #2 (result from last) is bound, FBO #1 is bound.
     *  Result is in texture #1.
     *
     * i = 2:
     *  Texture #1 is bound, FBO #2 is bound. Result is in texture #2.
     *
     * i = n:
     *  Texture #1 is bound if i is even.
     *  FBO #2     is bound if i is even.
     *  Result     is in #2 if i is even.
     *
     */

    for (var j in this.passes) {
        // swap (ping-pong technique)
        var even = !((j & 0x01) == 0);

        if (j+1 < this.passes.length) {
            if (even) fbo2.bind();
            else      fbo1.bind();

        // on the last pass, we draw directly to the screen, though.
        } else {
            glGlobals.activeRenderTarget.unbind();
            if (old_fbo) {
                old_fbo.bind();
            }
        }

        q.attachTexture(final_texture);
        q.draw(false, this.passes[j]);

        final_texture = even ? fbo2.texture : fbo1.texture;
    }
};

zogl.zSprite.prototype.offload = function(vao, flags) {
    for (var i in this.prims) {
        this.prims[i].offload(vao, flags);
    }
};

zogl.zSprite.prototype._drawPrims = function(ready, shader) {
    for (var i in this.prims) {
        var pos = [
            this.prims[i].getX(),
            this.prims[i].getY()
        ];

        if (this.flags.blend) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }

        this.prims[i].move(this.getX() + pos[0],
                           this.getY() + pos[1]);

        if (shader !== undefined) {
            shader.bind();
            this.prims[i].getTexture().bind();
        } else if (ready) {
            this.prims[i].prepareMaterial();
        }

        this.prims[i].draw(ready, shader);
        this.prims[i].move(pos[0], pos[1]);

        if (this.flags.blend && !this.prims[i+1]) {
            gl.disable(gl.BLEND);
        }
    }
};

zogl.zSprite.prototype.collides = function(x, y) {
    if (x.constructor == zogl.rect) {
        return this.rect.collideRect(x);
    } else if (x.constructor == zogl.zSprite) {
        return this.rect.collideRect(x.rect);
    }

    return this.rect.collidePosition(x, y);
};

zogl.zSprite.prototype.getX = function() {
    return this.rect.x;
};

zogl.zSprite.prototype.getY = function() {
    return this.rect.y;
};

zogl.zSprite.prototype.enable = function() {
    this.enabled = true;
};

zogl.zSprite.prototype.disable = function() {
    this.enabled = false;
};
zogl = zogl || {};

zogl.zFont = function() {
    this.size = 0;
    this.filename = "";
    this.node = null;
};

zogl.zFont.prototype.loadFromFile = function(css, size) {
    this.filename = css;
    this.size = size;

    this.node = document.createElement("canvas");
    this.node.id = "font-" + css;
    this.node.style.display = "none";
    this.node.context = this.node.getContext('2d');
    this.node.context.font = size + "px " + this.filename;

    document.body.appendChild(this.node);
};

zogl.zFont.prototype.draw = function(text) {
    this.node.width  = this.node.context.measureText(text).width;
    this.node.height = this.size * 2;
    this.node.context.font = this.size + "px " + this.filename;
    this.node.context.fillText(text, 0, this.size);

    var tx = new zogl.zTexture();
    tx.loadFromRaw(this.node, true);
    return tx;
};

zogl.zFont.prototype.drawOnSprite = function(text, sprite, x, y) {
    var tx = this.draw(text);
    var objs = sprite.prims;
    sprite.loadFromTexture(tx);
    sprite.prims[0].move(x || 0, y || 0);
    for (var i in objs) {
        sprite.addObject(objs[i], objs[i].getX(), objs[i].getY());
    }
}

zogl.zRenderTarget = function(w, h) {
    this.fbo = gl.createFramebuffer();
    this.rbo = gl.createRenderbuffer();
    this.texture = new zogl.zTexture();

    this.size = {
        'w': w || glGlobals.activeWindow.size.w,
        'h': h || glGlobals.activeWindow.size.h
    };

    this.proj = mat4.create();
    mat4.ortho(0, this.size.w, this.size.h, 0, 1.0, 10.0, this.proj);

    this.bind();

    this.texture.loadFromRaw(null, false, this.size.w, this.size.h);
    this.texture.bind();

    gl.bindRenderbuffer(gl.RENDERBUFFER, this.rbo);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
                           this.size.w, this.size.h);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                            gl.TEXTURE_2D, this.texture.id, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
                               gl.RENDERBUFFER, this.rbo);

    this.texture.unbind();
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    this.unbind();
};

zogl.zRenderTarget.prototype.clear = function(col) {
    col = new zogl.color4(col || '#000000');
    gl.clearColor(col.r, col.g, col.b, col.a);
    gl.clear(gl.COLOR_BUFFER_BIT);
};

zogl.zRenderTarget.prototype.bind = function() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    gl.viewport(0, 0, this.size.w, this.size.h);
    glGlobals.proj = this.proj;
    glGlobals.activeRenderTarget = this;
};

zogl.zRenderTarget.prototype.unbind = function() {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, glGlobals.activeWindow.size.w,
                      glGlobals.activeWindow.size.h);
    glGlobals.proj = glGlobals.activeWindow.proj;
    glGlobals.activeRenderTarget = null;
};

zogl.LightType = {
    'NO_LIGHT': -1,
    'AMBIENT':   0,
    'POINT':     1,
    'SPOT':      2
};

zogl.DefaultLightingConfig = {
    'attenuation':  new Float32Array([0.05, 0.01, 0.0]),
    'brightness':     1.0,
    'max_angle':     45.0,
    'min_angle':    -45.0,
    'color':        new zogl.color4('#FFFFFF').asGL(),
    'position':     new Float32Array([0.0, 0.0])
};

zogl.zLight = function(type, config) {
    config = config || zogl.DefaultLightingConfig;

    this.type = type || zogl.LightType.AMBIENT;
    this.config = {
        'brightness':   config.brightness   || zogl.DefaultLightingConfig.brightness,
        'attenuation':  config.attenuation  || zogl.DefaultLightingConfig.attenuation,
        'position':     config.position     || zogl.DefaultLightingConfig.position,
        'color':        config.color        || zogl.DefaultLightingConfig.color,
        'max_angle':    config.max_angle    || zogl.DefaultLightingConfig.max_angle,
        'min_angle':    config.min_angle    || zogl.DefaultLightingConfig.min_angle
    };

    var fragstr = zogl.SHADERS.defaultfs;

    if (this.type == zogl.LightType.AMBIENT) {
        fragstr = zogl.SHADERS.ambientLightFS;

    } else if (this.type == zogl.LightType.POINT) {
        fragstr = zogl.SHADERS.pointLightFS;

    } else if (this.type == zogl.LightType.SPOT) {
        fragstr = zogl.SHADERS.spotLightFS;
    }

    this.shader = new zogl.zShader();
    this.shader.loadFromString(zogl.SHADERS.defaultvs, fragstr);
    log('Shader errors:', this.shader.errorstr);

    this.update();
};

zogl.zLight.prototype.setBrightness = function(brightness) {
    this.config.brightness = brightness;
};

zogl.zLight.prototype.setColor = function(col) {
    this.config.color = typeof col == 'Object'  ?
                        col.asGL()              :
                        new zogl.color4(col).asGL();
};

zogl.zLight.prototype.setAttenuation = function(constant, linear, quadratic) {
    this.config.attenuation = new Float32Array([constant, linear, quadratic]);
};

zogl.zLight.prototype.setPosition = function(x, y) {
    this.config.position = new Float32Array([x, y]);
};

// TODO: Vector rotation not just value setting.

zogl.zLight.prototype.setMaxAngle = function(degrees) {
    this.config.max_angle = zogl.rad(degrees);
};

zogl.zLight.prototype.setMinAngle = function(degrees) {
    this.config.max_angle = zogl.rad(degrees);
};

zogl.zLight.prototype.update = function() {
    this.enable();
    this.shader.setParameterFl('light_col', this.config.color);
    this.shader.setParameterFl('light_pos', this.config.position);
    this.shader.setParameterFl('light_att', this.config.attenuation);
    this.shader.setParameterFl('light_brt', this.config.brightness);
    this.shader.setParameterFl('light_max', this.config.max_angle);
    this.shader.setParameterFl('light_min', this.config.min_angle);
    this.shader.setParameterInt('scr_height', glGlobals.activeWindow.size.h);
    this.disable();
};

zogl.zLight.prototype.enable = function() {
    var id = mat4.create();
    mat4.identity(id);

    this.shader.bind();
    this.shader.setParameterMat("mv", id);
    this.shader.setParameterMat("proj", glGlobals.proj);
};

zogl.zLight.prototype.disable = function() {
    this.shader.unbind();
};

zogl.zScene = function(w, h, options) {
    options = options || {};

    this.size = {
        'w': w || glGlobals.activeWindow.size.w,
        'h': h || glGlobals.activeWindow.size.h
    };

    this.geometryVAO = new zogl.zBufferSet(gl.DYNAMIC_DRAW);
    this.fbo1 = new zogl.zRenderTarget();
    this.fbo2 = new zogl.zRenderTarget();

    this.lights  = [];
    this.postfx  = [];
    this.objects = [];

    this.fullscreen = new zogl.zBufferSet();
    this.fullscreen.addIndices(new Uint16Array([
        0, 1, 3, 3, 1, 2
    ]));
    this.fullscreen.addPositions(new Float32Array([
        0,              0,
        this.size.w,    0,
        this.size.w,    this.size.h,
        0,              this.size.h
    ]));
    this.fullscreen.addColors(new Float32Array([
        1, 1, 1, 1,
        1, 1, 1, 1,
        1, 1, 1, 1,
        1, 1, 1, 1
    ]));
    this.fullscreen.addTexCoords(new Float32Array([
        0, 1,
        1, 1,
        1, 0,
        0, 0
    ]));
    this.fullscreen.offload();

    this.flags = {
        'lighting':         options.lighting        || false,
        'postProcessing':   options.postprocessing  || false,
        'blendThrough':     options.blendThrough    || false
    };
};

zogl.zScene.prototype.draw = function(color) {
    var color = new zogl.color4(color || [0.1, 0.1, 0.1, 1.0]);

    if (this.flags.blendThrough) {
        color.a = 0.0;
    }

    this.fbo2.bind(); this.fbo2.clear(color);
    this.fbo1.bind(); this.fbo1.clear(color);

    glGlobals.defaultShader.bind();
    for (var i in this.objects) {
        this.objects[i].offload(this.geometryVAO, { 'preserve': false });
    }

    this.geometryVAO.offload();
    this.geometryVAO.bind();

    for (var i in this.objects) {
        this.objects[i].draw(true);
    }

    var tx = this.fbo1.texture;

    if (this.flags.lighting) {
        this.fbo2.bind();
        tx.bind();
        gl.blendFunc(gl.ONE, gl.ONE);

        for (var i in this.lights) {
            this.lights[i].enable();
            this.fullscreen.draw();
            this.lights[i].disable();
        }

        tx = this.fbo2.texture;
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    }

    this.fbo1.unbind();

    var id = mat4.create();
    mat4.identity(id);

    tx.bind();
    glGlobals.defaultShader.bind();
    glGlobals.defaultShader.setParameterMat("proj", this.fbo1.proj);
    glGlobals.defaultShader.setParameterMat("mv",   id);

    this.fullscreen.draw();

    tx.unbind();
    glGlobals.defaultShader.unbind();
};

zogl.zScene.prototype.addObject = function(type, args) {
    type = type || zogl.zSprite;
    var z = new type(args);
    this.objects.push(z);
    return z;
};

zogl.zScene.prototype.addLight = function(type) {
    var z = new zogl.zLight(type);
    this.lights.push(z);
    return z;
};

